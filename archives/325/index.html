<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Nuclei POC模板编写笔记（一） | A10ng_&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="打不动了，开摸，很多地方（其实是基本上）都是cv的，原文是英文的，阅读不方便，记下来方便自己看看。。 基本介绍 id ID 不得包含空格。这样做是为了让">
<meta name="author" content="admin">
<link rel="canonical" href="https://a10nggg.github.io/archives/325/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://a10nggg.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://a10nggg.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://a10nggg.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://a10nggg.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://a10nggg.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://a10nggg.github.io/archives/325/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Nuclei POC模板编写笔记（一）" />
<meta property="og:description" content="打不动了，开摸，很多地方（其实是基本上）都是cv的，原文是英文的，阅读不方便，记下来方便自己看看。。 基本介绍 id ID 不得包含空格。这样做是为了让" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://a10nggg.github.io/archives/325/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-07T08:54:50+00:00" />
<meta property="article:modified_time" content="2022-08-07T08:54:50+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Nuclei POC模板编写笔记（一）"/>
<meta name="twitter:description" content="打不动了，开摸，很多地方（其实是基本上）都是cv的，原文是英文的，阅读不方便，记下来方便自己看看。。 基本介绍 id ID 不得包含空格。这样做是为了让"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://a10nggg.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Nuclei POC模板编写笔记（一）",
      "item": "https://a10nggg.github.io/archives/325/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Nuclei POC模板编写笔记（一）",
  "name": "Nuclei POC模板编写笔记（一）",
  "description": "打不动了，开摸，很多地方（其实是基本上）都是cv的，原文是英文的，阅读不方便，记下来方便自己看看。。 基本介绍 id ID 不得包含空格。这样做是为了让",
  "keywords": [
    
  ],
  "articleBody": "打不动了，开摸，很多地方（其实是基本上）都是cv的，原文是英文的，阅读不方便，记下来方便自己看看。。\n基本介绍 id ID 不得包含空格。这样做是为了让输出解析更容易。\nid: git-config 信息 关于模板的下一个重要信息是信息块。信息块提供 名称 、 作者 、 严重性 、 描述 、参考和 标签 。它还包含表示模板严重性的严重性字段，信息块还支持动态字段，因此可以定义N个key: value块以提供有关模板的更多有用信息。reference是另一个流行的标签，用于定义模板的外部参考链接。\n另一个总是添加到info块中的有用标签是 tags 。这允许您将一些自定义标签设置为模板，具体取决于目的等cve。rce这允许核心使用您的输入标签识别模板并仅运行它们。\ninfo: name: Git Config File Detection Template author: Ice3man severity: medium description: Searches for the pattern /.git/config on passed URLs. reference: https://www.acunetix.com/vulnerabilities/web/git-repository-found/ tags: git,config 实际请求和相应的匹配器被放置在信息块下方，它们执行向目标服务器发出请求并查找模板请求是否成功的任务。\n基本请求 请求 Nuclei 为与 HTTP 协议相关的各种功能提供了广泛的支持。支持基于原始和模型的 HTTP 请求，以及非 RFC 客户端请求选项也支持。还可以指定有效负载，并且可以根据有效负载值以及本页面稍后显示的更多功能来转换原始请求。\nHTTP 请求以一个request块开始，该块指定模板请求的开始。\nrequests: 请求方法 根据poc需要，来决定请求方法GET 、 POST 、 PUT 、DELETE等。\nyamethod: GET 重定向 默认情况下不支持重定向。如果有需要，可以添加redirects: true在请求详细信息中启用。然后使用max-redirects字段，后面的数字是允许重定向的次数，默认情况下最多遵循 10 个重定向。\nrequests: - method: GET path: - \"{{BaseURL}}/login.php\" redirects: true max-redirects: 3 路径 请求的下一部分是请求的路径。动态变量可以放置在路径中以在运行时修改其行为。变量以开头{{和}}结尾并且区分大小写。\n{{BaseURL}} - 这将在请求的运行时替换为目标文件中指定的输入 URL。 {{RootURL}} - 这将在运行时将请求中的根 URL 替换为目标文件中指定的根 URL。 {{Hostname}} - 主机名变量被替换为主机名，包括运行时目标的端口。 {{Host}} - 这将在运行时替换目标文件中指定的输入主机的请求。 {{Port}} - 这将在请求中的运行时替换为目标文件中指定的输入端口。 {{Path}} - 这将在请求中的运行时替换为目标文件中指定的输入路径。 {{File}} - 这将在请求中的运行时替换为目标文件中指定的输入文件名。 {{Scheme}} - 这将在运行时按目标文件中指定的协议替换模板中的请求。 Variable Value {{BaseURL}} https://example.com:443/foo/bar.php {{RootURL}} https://example.com:443 {{Hostname}} example.com:443 {{Host}} example.com {{Port}} 443 {{Path}} /foo {{File}} bar.php {{Scheme}} https path: \"{{BaseURL}}/.git/config\" # This path will be replaced on execution with BaseURL # If BaseURL is set to https://abc.com then the # path will get replaced to the following: https://abc.com/.git/config 请求头 指定请求头。\n# headers contain the headers for the request headers: # Custom user-agent header User-Agent: Some-Random-User-Agent # Custom request origin Origin: https://google.com body 请求时需要发送的内容。\n# Body is a string sent along with the request body: \"{\\\"some random JSON\\\"}\" # Body is a string sent along with the request body: \"admin=test\" Session 在发起多个请求时，需要保持会话，可以添加cookie-reuse: true来保持多个请求时会话得到保持，这在有身份验证时很有用。\n# cookie-reuse accepts boolean input and false as default cookie-reuse: true 请求条件 请求条件允许检查多个请求之间的条件，以编写复杂的检查和涉及多个 HTTP 请求的漏洞利用以完成漏洞利用链。\n使用 DSL 匹配器，可以通过添加req-condition: true和 作为后缀的数字来使用相应的属性，status_code_1例如。status_code_3 body_2\nreq-condition: true matchers: - type: dsl dsl: - \"status_code_1 == 404 \u0026\u0026 status_code_2 == 200 \u0026\u0026 contains((body_2), 'secret_string')\" 最终HTTP请求 id: git-config info: name: Git Config File author: Ice3man severity: medium description: Searches for the pattern /.git/config on passed URLs. requests: - method: GET path: - \"{{BaseURL}}/.git/config\" matchers: - type: word words: - \"[core]\" 原始 HTTP 请求 另一种创建请求的方法是使用原始请求，它具有更大的灵活性和对 DSL 辅助函数的支持，例如以下请求（现在建议将Host标头保留为示例中的变量{{Hostname}}）、所有匹配器、提取器功能可以以与上述相同的方式与 RAW 请求一起使用。\nrequests: - raw: - | POST /path2/ HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded a=test\u0026b=pd 可以根据需要修改请求。Nuclei 请求是完全可配置的，这意味着可以配置和定义关于将发送到目标服务器的请求每个属性。\nRAW 请求格式还支持各种辅助函数，让我们可以使用输入进行运行时操作，能省不少事儿。\nraw: - | GET /manager/html HTTP/1.1 Host: {{Hostname}} Authorization: Basic {{base64('username:password')}} # Helper function to encode input at run time. HTTP 模糊测试 Nuclei 引擎支持 fuzzing 模块，允许以多种格式运行各种类型的Payload，可以使用简单的关键字定义占位符（或者使用{{helper_function(variable)}}在需要突变函数的情况下使用括号），并执行 batteringram 、pitchfork和clusterbomb攻击。这些攻击的词表需要在请求定义期间在 Payload 字段下定义，名称与关键字匹配，Nuclei 支持基于文件和模板中的词表引用，最后所有 DSL 功能都完全可用和支持，并且可以使用操纵最终值。\nPayloads是使用变量名称定义的，并且可以§ §或{{ }}在之间中引用。\n使用本地字典时：\n# HTTP Intruder fuzzing using local wordlist. payloads: paths: params.txt header: local.txt 使用列表时：\n# HTTP Intruder fuzzing using in template wordlist. payloads: password: - admin - guest - password 注意： 选择攻击类型时要注意，因为不正确的输入可能会导致异常。\n例如，如果在使用clusterbomborpitchfork作为攻击类型并且在有效负载部分中仅定义了一个变量，则模板将无法编译，因为clusterbomb或pitchfork期望在模板中使用多个变量。\n攻击模式 Nuclei 引擎支持多种攻击类型，包括batteringram默认类型，通常用于 fuzz 单个参数，clusterbomb以及pitchfork用于 fuzz 多个参数，其工作方式与经典 burp intruder 相同。\nType batteringram pitchfork clusterbomb Support batteringram batteringram在所有位置放置相同的Payload。它只使用一个Payload。它遍历Payload标记位并用Payload集合遍历替换所有位置。\npitchfork pitchfork每个位置使用一个有效载荷集。它将第一个Payload放在第一个位置，第二个Payload放在第二个位置，依此类推。\n然后它同时遍历所有Payload标记位。第一个请求使用每个Payload集合中的第一个Payload，第二个请求使用每个Payload集合中的第二个Payload，依此类推。\nclusterbomb clusterbomb攻击尝试所有不同的Payload组合。它仍然将第一个Payload放在第一个位置，将第二个有效载荷放在第二个位置。但是当它遍历有Payload集合时，它会尝试所有组合。\n然后它同时遍历所有Payload集合。第一个请求使用每个Payload集合中的第一个Payload，第二个请求使用每个Payload集合中的第二个Payload，依此类推。\n这种攻击类型对于蛮力攻击很有用。在第一个有效负载集中加载常用用户名列表，在第二个有效负载集中加载常用密码列表。然后，集束炸弹攻击将尝试所有组合。\nclusterbomb使用攻击进行模糊测试的示例。\nrequests: - raw: - | POST /?file={{path}} HTTP/1.1 User-Agent: {{header}} Host: {{Hostname}} payloads: path: helpers/wordlists/prams.txt header: helpers/wordlists/header.txt attack: clusterbomb # Defining HTTP fuzz attack type 不安全的 HTTP 请求 Nuclei 支持rawhttp以实现完整的请求控制和自定义，允许针对 HTTP 请求走私、host头注入、带有畸形字符的 CRLF 等问题 的任何类型的畸形请求 。\nrawhttp库默认是禁用的，可以通过包含unsafe: true在请求块中来启用。\nrequests: - raw: - |+ POST / HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded Content-Length: 150 Transfer-Encoding: chunked 0 GET /post?postId=5 HTTP/1.1 User-Agent: a\"/\u003e Content-Type: application/x-www-form-urlencoded Content-Length: 5 x=1 - |+ GET /post?postId=5 HTTP/1.1 Host: {{Hostname}} unsafe: true # Enables rawhttp client matchers: - type: dsl dsl: - 'contains(body, \"\")' 高级模糊测试 nuclei允许对 Web 服务器进行高级模糊测试。可以使用多个选项来调整 HTTP fuzzing 工作流程。\n流水线 添加了 HTTP Pipelining 支持，允许在同一连接上发送多个 HTTP 请求。\n在运行基于 HTTP 流水线的模板之前，请确保运行的目标支持 HTTP 流水线连接，否则核心引擎会回退到标准 HTTP 请求引擎。\n如果你想确认给定的域或子域列表支持 HTTP Pipelining，httpx有一个标志-pipeline可以这样做。\n配置显示nuclei的流水线属性的示例。\nunsafe: true pipeline: true pipeline-concurrent-connections: 40 pipeline-requests-per-connection: 25000 一个演示nucile流水线功能的示例模板\nid: pipeline-testing info: name: pipeline testing author: pdteam severity: info requests: - raw: - |+ GET /{{path}} HTTP/1.1 Host: {{Hostname}} Referer: {{BaseURL}} attack: batteringram payloads: path: path_wordlist.txt unsafe: true pipeline: true pipeline-concurrent-connections: 40 pipeline-requests-per-connection: 25000 matchers: - type: status part: header status: - 200 连接池 虽然早期版本的 nuclei 没有进行连接池，但用户现在可以配置模板以使用或不使用 HTTP 连接池。这允许根据需要进行更快的扫描。\n要在模板中启用连接池，threads可以使用要在有效负载部分中使用的相应线程数来定义属性。\nConnection: Close标头不能在 HTTP 连接池模板中使用，否则引擎将失败并回退到带有池的标准 HTTP 请求。\nid: fuzzing-example info: name: Connection pooling example author: pdteam severity: info requests: - raw: - | GET /protected HTTP/1.1 Host: {{Hostname}} Authorization: Basic {{base64('admin:§password§')}} attack: batteringram payloads: password: password.txt threads: 40 matchers-condition: and matchers: - type: status status: - 200 - type: word words: - \"Unique string\" part: body 走私 HTTP Smuggling 漏洞的最基本示例是 CL.TE Smuggling。下面提供了一个用于检测 CE.TL http走私 漏洞的示例模板，该模板使用unsafe: true基于 raw http 的请求的属性。\nid: CL.TE-http-smuggling info: name: HTTP request smuggling, basic CL.TE vulnerability author: pdteam severity: info lab: https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te requests: - raw: - |+ POST / HTTP/1.1 Host: {{Hostname}} Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G - |+ POST / HTTP/1.1 Host: {{Hostname}} Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G unsafe: true matchers: - type: word words: - 'Unrecognized method GPOST' 条件竞争 竞争条件是另一类不易通过传统工具自动化的错误。Burp Suite 为 Turbo Intruder 引入了一种 Gate 机制，其中所有请求的所有字节都被发送，期望同时发送最后一个字节，仅针对同步发送事件的所有请求一起发送。\n我们在 nuclei 引擎中实现了Gate机制，并允许它们通过模板运行，这使得对该特定 bug 类的测试变得简单且可移植。\n要在模板中启用竞争条件检查，race可以将属性设置为true并race_count定义要启动的同时请求的数量。\n下面是一个示例模板，其中使用逻辑相同的请求 10 次。\nid: race-condition-testing info: name: Race condition testing author: pdteam severity: info requests: - raw: - | POST /coupons HTTP/1.1 Host: {{Hostname}} promo_code=20OFF race: true race_count: 10 matchers: - type: status part: header status: - 200 nuclei -t race.yaml -target https://api.target.com\n多请求竞争条件测试\n对于需要发送多个请求以利用竞争条件的场景，我们可以使用线程。\n下面是一个示例模板，其中将使用同时发送多个 (5) 请求。\nthreads: 5 race: true threads是使用模板发出的用于执行竞争条件测试的请求总数。\nid: multi-request-race info: name: Race condition testing with multiple requests author: pd-team severity: info requests: - raw: - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=1 - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=2 - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=3 - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=4 - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=5 threads: 5 race: true 请求注释\n请求内联注释允许执行每个请求属性/行为覆盖。它们与 python/java 类注释非常相似，并且必须在 RFC 行之前放在请求中。目前，仅支持以下覆盖：\n@Host:它覆盖了请求的真实目标（通常是作为输入提供的主机/IP）。它支持带有 ip/domain、port 和 scheme 的语法，例如：domain.tld domain.tld:port http://domain.tld:port @tls-sni:它会覆盖 TLS 请求的 SNI 名称（通常是作为输入提供的主机名）。它支持任何文字，特殊值request.host使用Host标头的值。 - | @Host: https://projectdiscovery.io:443 POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 这特别有用，例如，在具有多个请求的模板的情况下，需要对特定主机执行第一个请求之后的一个请求（例如检查 API 有效性）：\nrequests: - raw: # this request will be sent to {{Hostname}} to get the token - | GET /getkey HTTP/1.1 Host: {{Hostname}} # This request will be sent instead to https://api.target.com:443 to verify the token validity - | @Host: https://api.target.com:443 GET /api/key={{token} HTTP/1.1 Host: api.target.com:443 extractors: - type: regex name: token part: body regex: # random extractor of strings between prefix and suffix - 'prefix(.*)suffix' matchers: - type: word part: body words: - valid token ",
  "wordCount" : "4279",
  "inLanguage": "en",
  "datePublished": "2022-08-07T08:54:50Z",
  "dateModified": "2022-08-07T08:54:50Z",
  "author":{
    "@type": "Person",
    "name": "admin"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://a10nggg.github.io/archives/325/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "A10ng_'s Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://a10nggg.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://a10nggg.github.io/" accesskey="h" title="A10ng_&#39;s Blog (Alt + H)">A10ng_&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://a10nggg.github.io/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://a10nggg.github.io/posts/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://a10nggg.github.io/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://a10nggg.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://a10nggg.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://a10nggg.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Nuclei POC模板编写笔记（一）
    </h1>
    <div class="post-meta"><span title='2022-08-07 08:54:50 +0000 +0000'>August 7, 2022</span>&nbsp;·&nbsp;admin

</div>
  </header> 
  <div class="post-content"><p>打不动了，开摸，很多地方（其实是基本上）都是cv的，原文是英文的，阅读不方便，记下来方便自己看看。。</p>
<h2 id="基本介绍">基本介绍<a hidden class="anchor" aria-hidden="true" href="#基本介绍">#</a></h2>
<h3 id="id">id<a hidden class="anchor" aria-hidden="true" href="#id">#</a></h3>
<p>ID 不得包含空格。这样做是为了让输出解析更容易。</p>
<pre><code class="language-yaml">id: git-config</code></pre>
<h3 id="信息">信息<a hidden class="anchor" aria-hidden="true" href="#信息">#</a></h3>
<p>关于模板的下一个重要信息是<strong>信息</strong>块。信息块提供 <strong>名称</strong> 、 <strong>作者</strong> 、 <strong>严重性</strong> 、 <strong>描述</strong> 、<strong>参考</strong>和 <strong>标签</strong> 。它还包含表示模板严重性的<strong>严重性字段，信息</strong>块还支持动态字段，因此可以定义N个<code>key: value</code>块以提供有关模板的更多有用信息。<strong>reference</strong>是另一个流行的标签，用于定义模板的外部参考链接。</p>
<p>另一个总是添加到<code>info</code>块中的有用标签是 <strong>tags</strong> 。这允许您将一些自定义标签设置为模板，具体取决于目的等<code>cve</code>。<code>rce</code>这允许核心使用您的输入标签识别模板并仅运行它们。</p>
<pre><code class="language-yaml">info:
  name: Git Config File Detection Template
  author: Ice3man
  severity: medium
  description: Searches for the pattern /.git/config on passed URLs.
  reference: https://www.acunetix.com/vulnerabilities/web/git-repository-found/
  tags: git,config</code></pre>
<p>实际请求和相应的匹配器被放置在信息块下方，它们执行向目标服务器发出请求并查找模板请求是否成功的任务。</p>
<h2 id="基本请求">基本请求<a hidden class="anchor" aria-hidden="true" href="#基本请求">#</a></h2>
<h3 id="请求">请求<a hidden class="anchor" aria-hidden="true" href="#请求">#</a></h3>
<p>Nuclei 为与 HTTP 协议相关的各种功能提供了广泛的支持。支持基于原始和模型的 HTTP 请求，以及非 RFC 客户端请求选项也支持。还可以指定有效负载，并且可以根据有效负载值以及本页面稍后显示的更多功能来转换原始请求。</p>
<p>HTTP 请求以一个<code>request</code>块开始，该块指定模板请求的开始。</p>
<pre><code class="language-yaml">requests:</code></pre>
<h4 id="请求方法">请求方法<a hidden class="anchor" aria-hidden="true" href="#请求方法">#</a></h4>
<p>根据poc需要，来决定请求方法<strong>GET</strong> 、 <strong>POST</strong> 、 <strong>PUT</strong> 、<strong>DELETE</strong>等。</p>
<pre><code class="language-yaml">yamethod: GET</code></pre>
<h4 id="重定向">重定向<a hidden class="anchor" aria-hidden="true" href="#重定向">#</a></h4>
<p>默认情况下不支持重定向。如果有需要，可以添加<code>redirects: true</code>在请求详细信息中启用。然后使用<code>max-redirects</code>字段，后面的数字是允许重定向的次数，默认情况下最多遵循 10 个重定向。</p>
<pre><code class="language-yaml">requests:
  - method: GET
    path:
      - "{{BaseURL}}/login.php"
    redirects: true
    max-redirects: 3</code></pre>
<h4 id="路径">路径<a hidden class="anchor" aria-hidden="true" href="#路径">#</a></h4>
<p>请求的下一部分是请求的路径。动态变量可以放置在路径中以在运行时修改其行为。变量以开头<code>{{</code>和<code>}}</code>结尾并且区分大小写。</p>
<pre><code class="language-yaml">{{BaseURL}} - 这将在请求的运行时替换为目标文件中指定的输入 URL。

{{RootURL}} - 这将在运行时将请求中的根 URL 替换为目标文件中指定的根 URL。

{{Hostname}} - 主机名变量被替换为主机名，包括运行时目标的端口。

{{Host}} - 这将在运行时替换目标文件中指定的输入主机的请求。

{{Port}} - 这将在请求中的运行时替换为目标文件中指定的输入端口。

{{Path}} - 这将在请求中的运行时替换为目标文件中指定的输入路径。

{{File}} - 这将在请求中的运行时替换为目标文件中指定的输入文件名。

{{Scheme}} - 这将在运行时按目标文件中指定的协议替换模板中的请求。</code></pre>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>{{BaseURL}}</td>
<td><a href="https://example.com/foo/bar.php">https://example.com:443/foo/bar.php</a></td>
</tr>
<tr>
<td>{{RootURL}}</td>
<td><a href="https://example.com/">https://example.com:443</a></td>
</tr>
<tr>
<td>{{Hostname}}</td>
<td>example.com:443</td>
</tr>
<tr>
<td>{{Host}}</td>
<td>example.com</td>
</tr>
<tr>
<td>{{Port}}</td>
<td>443</td>
</tr>
<tr>
<td>{{Path}}</td>
<td>/foo</td>
</tr>
<tr>
<td>{{File}}</td>
<td>bar.php</td>
</tr>
<tr>
<td>{{Scheme}}</td>
<td>https</td>
</tr>
</tbody>
</table>
<pre><code class="language-yaml">path: "{{BaseURL}}/.git/config"
# This path will be replaced on execution with BaseURL
# If BaseURL is set to  https://abc.com then the
# path will get replaced to the following: https://abc.com/.git/config</code></pre>
<h4 id="请求头">请求头<a hidden class="anchor" aria-hidden="true" href="#请求头">#</a></h4>
<p>指定请求头。</p>
<pre><code class="language-yaml"># headers contain the headers for the request
headers:
  # Custom user-agent header
  User-Agent: Some-Random-User-Agent
  # Custom request origin
  Origin: https://google.com</code></pre>
<h4 id="body">body<a hidden class="anchor" aria-hidden="true" href="#body">#</a></h4>
<p>请求时需要发送的内容。</p>
<pre><code class="language-yaml"># Body is a string sent along with the request
body: "{\"some random JSON\"}"

# Body is a string sent along with the request
body: "admin=test"</code></pre>
<h4 id="session">Session<a hidden class="anchor" aria-hidden="true" href="#session">#</a></h4>
<p>在发起多个请求时，需要保持会话，可以添加<code>cookie-reuse: true</code>来保持多个请求时会话得到保持，这在有身份验证时很有用。</p>
<pre><code class="language-yaml"># cookie-reuse accepts boolean input and false as default
cookie-reuse: true</code></pre>
<h4 id="请求条件">请求条件<a hidden class="anchor" aria-hidden="true" href="#请求条件">#</a></h4>
<p>请求条件允许检查多个请求之间的条件，以编写复杂的检查和涉及多个 HTTP 请求的漏洞利用以完成漏洞利用链。</p>
<p>使用 DSL 匹配器，可以通过添加<code>req-condition: true</code>和 作为后缀的数字来使用相应的属性，<code>status_code_1</code>例如。<code>status_code_3</code> <code>body_2</code></p>
<pre><code class="language-yaml">    req-condition: true
    matchers:
      - type: dsl
        dsl:
          - "status_code_1 == 404 && status_code_2 == 200 && contains((body_2), &#039;secret_string&#039;)"</code></pre>
<h4 id="最终http请求">最终HTTP请求<a hidden class="anchor" aria-hidden="true" href="#最终http请求">#</a></h4>
<pre><code class="language-yaml">id: git-config

info:
  name: Git Config File
  author: Ice3man
  severity: medium
  description: Searches for the pattern /.git/config on passed URLs.

requests:
  - method: GET
    path:
      - "{{BaseURL}}/.git/config"
    matchers:
      - type: word
        words:
          - "[core]"</code></pre>
<h3 id="原始-http-请求">原始 HTTP 请求<a hidden class="anchor" aria-hidden="true" href="#原始-http-请求">#</a></h3>
<p>另一种创建请求的方法是使用原始请求，它具有更大的灵活性和对 DSL 辅助函数的支持，例如以下请求（现在建议将<code>Host</code>标头保留为示例中的变量<code>{{Hostname}}</code>）、所有匹配器、提取器功能可以以与上述相同的方式与 RAW 请求一起使用。</p>
<pre><code class="language-yaml">requests:
  - raw:
    - |
        POST /path2/ HTTP/1.1
        Host: {{Hostname}}
        Content-Type: application/x-www-form-urlencoded

        a=test&b=pd</code></pre>
<p>可以根据需要修改请求。Nuclei 请求是完全可配置的，这意味着可以配置和定义关于将发送到目标服务器的请求每个属性。</p>
<p>RAW 请求格式还支持<a href="https://nuclei.projectdiscovery.io/templating-guide/helper-functions/">各种辅助函数</a>，让我们可以使用输入进行运行时操作，能省不少事儿。</p>
<pre><code class="language-yaml">    raw:
      - |
        GET /manager/html HTTP/1.1
        Host: {{Hostname}}
        Authorization: Basic {{base64(&#039;username:password&#039;)}} # Helper function to encode input at run time.</code></pre>
<h3 id="http-模糊测试">HTTP 模糊测试<a hidden class="anchor" aria-hidden="true" href="#http-模糊测试">#</a></h3>
<p>Nuclei 引擎支持 fuzzing 模块，允许以多种格式运行各种类型的Payload，可以使用简单的关键字定义占位符（或者使用<code>{{helper_function(variable)}}</code>在需要突变函数的情况下使用括号），并执行 <strong>batteringram</strong> 、<strong>pitchfork</strong>和<strong>clusterbomb</strong>攻击。这些攻击的词表需要在请求定义期间在 Payload 字段下定义，名称与关键字匹配，Nuclei 支持基于文件和模板中的词表引用，最后所有 DSL 功能都完全可用和支持，并且可以使用操纵最终值。</p>
<p>Payloads是使用变量名称定义的，并且可以<code>§ §</code>或<code>{{ }}</code>在之间中引用。</p>
<p>使用本地字典时：</p>
<pre><code class="language-yaml">    # HTTP Intruder fuzzing using local wordlist.

    payloads:
      paths: params.txt
      header: local.txt</code></pre>
<p>使用列表时：</p>
<pre><code class="language-yaml">    # HTTP Intruder fuzzing using in template wordlist.

    payloads:
      password:
        - admin
        - guest
        - password</code></pre>
<p><strong>注意：</strong> 选择攻击类型时要注意，因为不正确的输入可能会导致异常。</p>
<p>例如，如果在使用<code>clusterbomb</code>or<code>pitchfork</code>作为攻击类型并且在有效负载部分中仅定义了一个变量，则模板将无法编译，因为<code>clusterbomb</code>或<code>pitchfork</code>期望在模板中使用多个变量。</p>
<h4 id="攻击模式">攻击模式<a hidden class="anchor" aria-hidden="true" href="#攻击模式">#</a></h4>
<p>Nuclei 引擎支持多种攻击类型，包括<code>batteringram</code>默认类型，通常用于 fuzz 单个参数，<code>clusterbomb</code>以及<code>pitchfork</code>用于 fuzz 多个参数，其工作方式与经典 burp intruder 相同。</p>
<table>
  <tr>
    <th>
      Type
    </th>
<pre><code>&lt;th&gt;
  batteringram
&lt;/th&gt;

&lt;th&gt;
  pitchfork
&lt;/th&gt;

&lt;th&gt;
  clusterbomb
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      Support
    </td>
  </tr>
</table>
<h4 id="batteringram">batteringram<a hidden class="anchor" aria-hidden="true" href="#batteringram">#</a></h4>
<p>batteringram在所有位置放置相同的Payload。它只使用一个Payload。它遍历Payload标记位并用Payload集合遍历替换所有位置。</p>
<h4 id="pitchfork">pitchfork<a hidden class="anchor" aria-hidden="true" href="#pitchfork">#</a></h4>
<p>pitchfork每个位置使用一个有效载荷集。它将第一个Payload放在第一个位置，第二个Payload放在第二个位置，依此类推。</p>
<p>然后它同时遍历所有Payload标记位。第一个请求使用每个Payload集合中的第一个Payload，第二个请求使用每个Payload集合中的第二个Payload，依此类推。</p>
<h4 id="clusterbomb">clusterbomb<a hidden class="anchor" aria-hidden="true" href="#clusterbomb">#</a></h4>
<p>clusterbomb攻击尝试所有不同的Payload组合。它仍然将第一个Payload放在第一个位置，将第二个有效载荷放在第二个位置。但是当它遍历有Payload集合时，它会尝试所有组合。</p>
<p>然后它同时遍历所有Payload集合。第一个请求使用每个Payload集合中的第一个Payload，第二个请求使用每个Payload集合中的第二个Payload，依此类推。</p>
<p>这种攻击类型对于蛮力攻击很有用。在第一个有效负载集中加载常用用户名列表，在第二个有效负载集中加载常用密码列表。然后，集束炸弹攻击将尝试所有组合。</p>
<p><code>clusterbomb</code>使用攻击进行模糊测试的示例。</p>
<pre><code class="language-yaml">requests:
  - raw:
      - |
        POST /?file={{path}} HTTP/1.1
        User-Agent: {{header}}
        Host: {{Hostname}}

    payloads:
      path: helpers/wordlists/prams.txt
      header: helpers/wordlists/header.txt
    attack: clusterbomb # Defining HTTP fuzz attack type</code></pre>
<h4 id="不安全的-http-请求">不安全的 HTTP 请求<a hidden class="anchor" aria-hidden="true" href="#不安全的-http-请求">#</a></h4>
<p>Nuclei 支持<a href="https://github.com/projectdiscovery/rawhttp">rawhttp</a>以实现完整的请求控制和自定义，允许针对 HTTP 请求走私、host头注入、带有畸形字符的 CRLF 等问题 <strong>的任何类型的畸形请求</strong> 。</p>
<p><strong>rawhttp</strong>库默认是禁用的，可以通过包含<code>unsafe: true</code>在请求块中来启用。</p>
<pre><code class="language-yaml">requests:
  - raw:
    - |+
        POST / HTTP/1.1
        Host: {{Hostname}}
        Content-Type: application/x-www-form-urlencoded
        Content-Length: 150
        Transfer-Encoding: chunked

        0

        GET /post?postId=5 HTTP/1.1
        User-Agent: a"/&gt;&lt;script&gt;alert(1)&lt;/script&gt;
        Content-Type: application/x-www-form-urlencoded
        Content-Length: 5

        x=1
    - |+
        GET /post?postId=5 HTTP/1.1
        Host: {{Hostname}}

    unsafe: true # Enables rawhttp client
    matchers:
      - type: dsl
        dsl:
          - &#039;contains(body, "&lt;script&gt;alert(1)&lt;/script&gt;")&#039;</code></pre>
<h3 id="高级模糊测试">高级模糊测试<a hidden class="anchor" aria-hidden="true" href="#高级模糊测试">#</a></h3>
<p>nuclei允许对 Web 服务器进行高级模糊测试。可以使用多个选项来调整 HTTP fuzzing 工作流程。</p>
<h4 id="流水线">流水线<a hidden class="anchor" aria-hidden="true" href="#流水线">#</a></h4>
<p>添加了 HTTP Pipelining 支持，允许在同一连接上发送多个 HTTP 请求。</p>
<p>在运行基于 HTTP 流水线的模板之前，请确保运行的目标支持 HTTP 流水线连接，否则核心引擎会回退到标准 HTTP 请求引擎。</p>
<p>如果你想确认给定的域或子域列表支持 HTTP Pipelining，httpx有一个标志<code>-pipeline</code>可以这样做。</p>
<p>配置显示nuclei的流水线属性的示例。</p>
<pre><code class="language-yaml">    unsafe: true
    pipeline: true
    pipeline-concurrent-connections: 40
    pipeline-requests-per-connection: 25000</code></pre>
<p>一个演示nucile流水线功能的示例模板</p>
<pre><code class="language-yaml">id: pipeline-testing
info:
  name: pipeline testing
  author: pdteam
  severity: info

requests:
  - raw:
      - |+
        GET /{{path}} HTTP/1.1
        Host: {{Hostname}}
        Referer: {{BaseURL}}

    attack: batteringram
    payloads:
      path: path_wordlist.txt

    unsafe: true
    pipeline: true
    pipeline-concurrent-connections: 40
    pipeline-requests-per-connection: 25000

    matchers:
      - type: status
        part: header
        status:
          - 200</code></pre>
<h4 id="连接池">连接池<a hidden class="anchor" aria-hidden="true" href="#连接池">#</a></h4>
<p>虽然早期版本的 nuclei 没有进行连接池，但用户现在可以配置模板以使用或不使用 HTTP 连接池。这允许根据需要进行更快的扫描。</p>
<p>要在模板中启用连接池，<code>threads</code>可以使用要在有效负载部分中使用的相应线程数来定义属性。</p>
<p><code>Connection: Close</code>标头不能在 HTTP 连接池模板中使用，否则引擎将失败并回退到带有池的标准 HTTP 请求。</p>
<pre><code class="language-yaml">id: fuzzing-example
info:
  name: Connection pooling example
  author: pdteam
  severity: info

requests:

  - raw:
      - |
        GET /protected HTTP/1.1
        Host: {{Hostname}}
        Authorization: Basic {{base64(&#039;admin:§password§&#039;)}}

    attack: batteringram
    payloads:
      password: password.txt
    threads: 40

    matchers-condition: and
    matchers:
      - type: status
        status:
          - 200

      - type: word
        words:
          - "Unique string"
        part: body</code></pre>
<h4 id="走私">走私<a hidden class="anchor" aria-hidden="true" href="#走私">#</a></h4>
<p>HTTP Smuggling 漏洞的最基本示例是 CL.TE Smuggling。下面提供了一个用于检测 CE.TL http走私 漏洞的示例模板，该模板使用<code>unsafe: true</code>基于 raw http 的请求的属性。</p>
<pre><code class="language-yaml">id: CL.TE-http-smuggling

info:
  name: HTTP request smuggling, basic CL.TE vulnerability
  author: pdteam
  severity: info
  lab: https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te

requests:
  - raw:
    - |+
      POST / HTTP/1.1
      Host: {{Hostname}}
      Connection: keep-alive
      Content-Type: application/x-www-form-urlencoded
      Content-Length: 6
      Transfer-Encoding: chunked

      0

      G    
    - |+
      POST / HTTP/1.1
      Host: {{Hostname}}
      Connection: keep-alive
      Content-Type: application/x-www-form-urlencoded
      Content-Length: 6
      Transfer-Encoding: chunked

      0

      G

    unsafe: true
    matchers:
      - type: word
        words:
          - &#039;Unrecognized method GPOST&#039;</code></pre>
<h4 id="条件竞争">条件竞争<a hidden class="anchor" aria-hidden="true" href="#条件竞争">#</a></h4>
<p>竞争条件是另一类不易通过传统工具自动化的错误。Burp Suite 为 Turbo Intruder 引入了一种 Gate 机制，其中所有请求的所有字节都被发送，期望同时发送最后一个字节，仅针对同步发送事件的所有请求一起发送。</p>
<p>我们在 nuclei 引擎中实现了<strong>Gate</strong>机制，并允许它们通过模板运行，这使得对该特定 bug 类的测试变得简单且可移植。</p>
<p>要在模板中启用竞争条件检查，<code>race</code>可以将属性设置为<code>true</code>并<code>race_count</code>定义要启动的同时请求的数量。</p>
<p>下面是一个示例模板，其中使用逻辑相同的请求 10 次。</p>
<pre><code class="language-yaml">id: race-condition-testing

info:
  name: Race condition testing
  author: pdteam
  severity: info

requests:
  - raw:
      - |
        POST /coupons HTTP/1.1
        Host: {{Hostname}}

        promo_code=20OFF      

    race: true
    race_count: 10

    matchers:
      - type: status
        part: header
        status:
          - 200</code></pre>
<p><code>nuclei -t race.yaml -target https://api.target.com</code></p>
<p><strong>多请求竞争条件测试</strong></p>
<p>对于需要发送多个请求以利用竞争条件的场景，我们可以使用线程。</p>
<p>下面是一个示例模板，其中将使用同时发送多个 (5) 请求。</p>
<pre><code class="language-yaml">    threads: 5
    race: true</code></pre>
<p><code>threads</code>是使用模板发出的用于执行竞争条件测试的请求总数。</p>
<pre><code class="language-yaml">id: multi-request-race

info:
  name: Race condition testing with multiple requests
  author: pd-team
  severity: info

requests:
  - raw:  
      - |
        POST / HTTP/1.1
        Pragma: no-cache
        Host: {{Hostname}}
        Cache-Control: no-cache, no-transform
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0

        id=1

      - |
        POST / HTTP/1.1
        Pragma: no-cache
        Host: {{Hostname}}
        Cache-Control: no-cache, no-transform
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0

        id=2

      - |
        POST / HTTP/1.1
        Pragma: no-cache
        Host: {{Hostname}}
        Cache-Control: no-cache, no-transform
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0

        id=3

      - |
        POST / HTTP/1.1
        Pragma: no-cache
        Host: {{Hostname}}
        Cache-Control: no-cache, no-transform
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0

        id=4

      - |
        POST / HTTP/1.1
        Pragma: no-cache
        Host: {{Hostname}}
        Cache-Control: no-cache, no-transform
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0

        id=5

    threads: 5
    race: true</code></pre>
<p><strong>请求注释</strong></p>
<p>请求内联注释允许执行每个请求属性/行为覆盖。它们与 python/java 类注释非常相似，并且必须在 RFC 行之前放在请求中。目前，仅支持以下覆盖：</p>
<ul>
<li><code>@Host:</code>它覆盖了请求的真实目标（通常是作为输入提供的主机/IP）。它支持带有 ip/domain、port 和 scheme 的语法，例如：<code>domain.tld</code> <code>domain.tld:port</code> <code>http://domain.tld:port</code></li>
<li><code>@tls-sni:</code>它会覆盖 TLS 请求的 SNI 名称（通常是作为输入提供的主机名）。它支持任何文字，特殊值<code>request.host</code>使用<code>Host</code>标头的值。</li>
</ul>
<pre><code class="language-yaml">- |
  @Host: https://projectdiscovery.io:443
  POST / HTTP/1.1
  Pragma: no-cache
  Host: {{Hostname}}
  Cache-Control: no-cache, no-transform
  User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0</code></pre>
<p>这特别有用，例如，在具有多个请求的模板的情况下，需要对特定主机执行第一个请求之后的一个请求（例如检查 API 有效性）：</p>
<pre><code class="language-yaml">requests:
  - raw:
      # this request will be sent to {{Hostname}} to get the token
      - |
        GET /getkey HTTP/1.1
        Host: {{Hostname}}

      # This request will be sent instead to https://api.target.com:443 to verify the token validity
      - |
        @Host: https://api.target.com:443
        GET /api/key={{token} HTTP/1.1
        Host: api.target.com:443

    extractors:
      - type: regex
        name: token
        part: body
        regex:
          # random extractor of strings between prefix and suffix
          - &#039;prefix(.*)suffix&#039;

    matchers:
      - type: word
        part: body
        words:
          - valid token</code></pre>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://a10nggg.github.io/">A10ng_&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
